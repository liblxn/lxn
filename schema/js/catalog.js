// Code generated by mprotc.
// Do not edit.

import {Bool, Int, Str, Struct, TypedArr, TypedMap, Uint, Union} from "messagepack";


// Catalog holds the data for a message catalog which includes localized
// messages and the locale information needed to format numbers and plurals.
export const Catalog = Struct({
	1: ["version", Int],
	2: ["locale", Locale],
	3: ["messages", _MessageArr],
});

// Symbols holds all the symbols that are used to format a number in a specific locale.
export const Symbols = Struct({
	1: ["decimal", Str],
	2: ["group", Str],
	3: ["percent", Str],
	4: ["minus", Str],
	5: ["inf", Str],
	6: ["nan", Str],
	7: ["zero", Uint],
});

// NumberFormat holds all relevant information to format a number in a specific locale.
export const NumberFormat = Struct({
	1: ["symbols", Symbols],
	2: ["positivePrefix", Str],
	3: ["positiveSuffix", Str],
	4: ["negativePrefix", Str],
	5: ["negativeSuffix", Str],
	6: ["minIntegerDigits", Int],
	7: ["minFractionDigits", Int],
	8: ["maxFractionDigits", Int],
	9: ["primaryIntegerGrouping", Int],
	10: ["secondaryIntegerGrouping", Int],
	11: ["fractionGrouping", Int],
});

// PluralTag is an enumeration of supported plural types. Each plural tag
// can have its own translation text.
export const PluralTag = Int

// Operand represents an operand in a plural rule.
export const Operand = Int

// Connective represents a logical connective for two plural rules. Two plural
// rules can be connected by a conjunction ('and' operator) or a disjunction
// ('or' operator). The conjunction binds more tightly.
export const Connective = Int

// Range represents an integer range, where both bounds are inclusive.
// If the lower bound equals the upper bound, the range will collapse
// to a single value.
export const Range = Struct({
	1: ["lowerBound", Int],
	2: ["upperBound", Int],
});

// PluralRule holds the data for a single plural rule. The Modulo field defines the
// modulo divisor for the operand. If Modulo is zero, no remainder has to be calculated.
//
// The plural rule could be connected with another rule. If so, the Connective field is
// set to the respective value (Conjunction or Disjunction). Otherwise the Connective
// field is set to None and there is no follow-up rule.
//
// Example for a plural rule: i%10=1..3
export const PluralRule = Struct({
	1: ["operand", Operand],
	2: ["modulo", Int],
	3: ["negate", Bool],
	4: ["ranges", _RangeArr],
	5: ["connective", Connective],
});

// Plural represents a single plural form. It holds a collection of plural rules
// for a specific plural tag where all rules are connected with each other (see
// Rule and Connective).
export const Plural = Struct({
	1: ["tag", PluralTag],
	2: ["rules", _PluralRuleArr],
});

// Locale holds the data which is necessary to format data in a region
// specific format.
export const Locale = Struct({
	1: ["id", Str],
	2: ["decimalFormat", NumberFormat],
	3: ["moneyFormat", NumberFormat],
	4: ["percentFormat", NumberFormat],
	5: ["cardinalPlurals", _PluralArr],
	6: ["ordinalPlurals", _PluralArr],
});

// Message holds the data for a single message. Each message consists of
// a list of fragments which has to be concatenated to receive the final
// message text. If the message does not contain any replacement variables,
// there will only be a single string fragment.
export const Message = Struct({
	1: ["section", Str],
	2: ["key", Str],
	3: ["text", _StrArr],
	4: ["replacements", _ReplacementArr],
});

// Replacement describes a variable piece of text in a message which will be replaced
// during runtime. The key defines the variable's name which will be passed in. The type
// contains more details about the particular replacement.
export const Replacement = Struct({
	1: ["key", Str],
	2: ["textPos", Int],
	3: ["type", ReplacementType],
	4: ["details", ReplacementDetails],
});

// ReplacementDetails holds the details for particular replacements. The special
// EmptyDetails branch indicates that there a no details for the replacement type.
export const ReplacementDetails = Union({
	1: EmptyDetails,
	2: MoneyDetails,
	3: PluralDetails,
	4: SelectDetails,
	ordinalOf(v) {
		switch(typeof v) {
		case "object":
			if(v) {
				if("currency" in v) {
					return 2; // MoneyDetails
				}
				if("type" in v && "variants" in v && "custom" in v) {
					return 3; // PluralDetails
				}
				if("cases" in v && "fallback" in v) {
					return 4; // SelectDetails
				}
			}
			return 1; // EmptyDetails
		default:
			throw new TypeError("invalid union type");
		}
	},
});

// ReplacementType describes the type of a replacement. Each type contains the details
// necessary to render the variable's value.
export const ReplacementType = Int

// PluralType is an enumeration for the types of a plural form.
export const PluralType = Int

// EmptyDetails describes a special type for a replacement that has no further
// details attached.
export const EmptyDetails = Struct({
});

// MoneyDetails contains the replacement details for amounts of money.
export const MoneyDetails = Struct({
	1: ["currency", Str],
});

// PluralDetails contains the replacement details for plurals. Depending on the
// variable, different text for each plural rule can be selected. It contains
// the variants for the supported plural tags and custom overwrites.
export const PluralDetails = Struct({
	1: ["type", PluralType],
	2: ["variants", _PluralTagMessageMap],
	3: ["custom", _IntMessageMap],
});

// SelectDetails contains the replacement details to select a text fragment
// depending on the given variable. The fallback is an optional value which
// describes the default case.
export const SelectDetails = Struct({
	1: ["cases", _StrMessageMap],
	2: ["fallback", Str],
});

// required collection types
const _IntMessageMap = TypedMap(Int, Message);
const _MessageArr = TypedArr(Message);
const _PluralArr = TypedArr(Plural);
const _PluralRuleArr = TypedArr(PluralRule);
const _PluralTagMessageMap = TypedMap(PluralTag, Message);
const _RangeArr = TypedArr(Range);
const _ReplacementArr = TypedArr(Replacement);
const _StrArr = TypedArr(Str);
const _StrMessageMap = TypedMap(Str, Message);
