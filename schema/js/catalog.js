// Code generated by mprotc.
// Do not edit.

import {Any, Arr, Bool, Int, Map, Str, TypedArr, TypedMap, Uint} from "messagepack";


// Catalog holds the data for a message catalog which includes localized
// messages and the locale information needed to format numbers and plurals.
export const Catalog = {
	enc(buf, v) {
		Map.encHeader(buf, 3);
		for(const k in __meta.Catalog) {
			const f = __meta.Catalog[k];
			Int.enc(buf, k);
			f[1].enc(buf, v[f[0]]);
		}
	},

	dec(buf) {
		const res = {};
		for(let n = Map.decHeader(buf); n > 0; --n) {
			const f = __meta.Catalog[Int.dec(buf)];
			if(f) {
				res[f[0]] = f[1].dec(buf);
			} else {
				Any.dec(buf);
			}
		}
		return res;
	},
};

// Symbols holds all the symbols that are used to format a number in a specific locale.
export const Symbols = {
	enc(buf, v) {
		Map.encHeader(buf, 7);
		for(const k in __meta.Symbols) {
			const f = __meta.Symbols[k];
			Int.enc(buf, k);
			f[1].enc(buf, v[f[0]]);
		}
	},

	dec(buf) {
		const res = {};
		for(let n = Map.decHeader(buf); n > 0; --n) {
			const f = __meta.Symbols[Int.dec(buf)];
			if(f) {
				res[f[0]] = f[1].dec(buf);
			} else {
				Any.dec(buf);
			}
		}
		return res;
	},
};

// NumberFormat holds all relevant information to format a number in a specific locale.
export const NumberFormat = {
	enc(buf, v) {
		Map.encHeader(buf, 11);
		for(const k in __meta.NumberFormat) {
			const f = __meta.NumberFormat[k];
			Int.enc(buf, k);
			f[1].enc(buf, v[f[0]]);
		}
	},

	dec(buf) {
		const res = {};
		for(let n = Map.decHeader(buf); n > 0; --n) {
			const f = __meta.NumberFormat[Int.dec(buf)];
			if(f) {
				res[f[0]] = f[1].dec(buf);
			} else {
				Any.dec(buf);
			}
		}
		return res;
	},
};

// PluralTag is an enumeration of supported plural types. Each plural tag
// can have its own translation text.
export const PluralTag = Int

// Operand represents an operand in a plural rule.
export const Operand = Int

// Connective represents a logical connective for two plural rules. Two plural
// rules can be connected by a conjunction ('and' operator) or a disjunction
// ('or' operator). The conjunction binds more tightly.
export const Connective = Int

// Range represents an integer range, where both bounds are inclusive.
// If the lower bound equals the upper bound, the range will collapse
// to a single value.
export const Range = {
	enc(buf, v) {
		Map.encHeader(buf, 2);
		for(const k in __meta.Range) {
			const f = __meta.Range[k];
			Int.enc(buf, k);
			f[1].enc(buf, v[f[0]]);
		}
	},

	dec(buf) {
		const res = {};
		for(let n = Map.decHeader(buf); n > 0; --n) {
			const f = __meta.Range[Int.dec(buf)];
			if(f) {
				res[f[0]] = f[1].dec(buf);
			} else {
				Any.dec(buf);
			}
		}
		return res;
	},
};

// PluralRule holds the data for a single plural rule. The Modulo field defines the
// modulo divisor for the operand. If Modulo is zero, no remainder has to be calculated.
//
// The plural rule could be connected with another rule. If so, the Connective field is
// set to the respective value (Conjunction or Disjunction). Otherwise the Connective
// field is set to None and there is no follow-up rule.
//
// Example for a plural rule: i%10=1..3
export const PluralRule = {
	enc(buf, v) {
		Map.encHeader(buf, 5);
		for(const k in __meta.PluralRule) {
			const f = __meta.PluralRule[k];
			Int.enc(buf, k);
			f[1].enc(buf, v[f[0]]);
		}
	},

	dec(buf) {
		const res = {};
		for(let n = Map.decHeader(buf); n > 0; --n) {
			const f = __meta.PluralRule[Int.dec(buf)];
			if(f) {
				res[f[0]] = f[1].dec(buf);
			} else {
				Any.dec(buf);
			}
		}
		return res;
	},
};

// Plural represents a single plural form. It holds a collection of plural rules
// for a specific plural tag where all rules are connected with each other (see
// Rule and Connective).
export const Plural = {
	enc(buf, v) {
		Map.encHeader(buf, 2);
		for(const k in __meta.Plural) {
			const f = __meta.Plural[k];
			Int.enc(buf, k);
			f[1].enc(buf, v[f[0]]);
		}
	},

	dec(buf) {
		const res = {};
		for(let n = Map.decHeader(buf); n > 0; --n) {
			const f = __meta.Plural[Int.dec(buf)];
			if(f) {
				res[f[0]] = f[1].dec(buf);
			} else {
				Any.dec(buf);
			}
		}
		return res;
	},
};

// Locale holds the data which is necessary to format data in a region
// specific format.
export const Locale = {
	enc(buf, v) {
		Map.encHeader(buf, 6);
		for(const k in __meta.Locale) {
			const f = __meta.Locale[k];
			Int.enc(buf, k);
			f[1].enc(buf, v[f[0]]);
		}
	},

	dec(buf) {
		const res = {};
		for(let n = Map.decHeader(buf); n > 0; --n) {
			const f = __meta.Locale[Int.dec(buf)];
			if(f) {
				res[f[0]] = f[1].dec(buf);
			} else {
				Any.dec(buf);
			}
		}
		return res;
	},
};

// Message holds the data for a single message. Each message consists of
// a list of fragments which has to be concatenated to receive the final
// message text. If the message does not contain any replacement variables,
// there will only be a single string fragment.
export const Message = {
	enc(buf, v) {
		Map.encHeader(buf, 4);
		for(const k in __meta.Message) {
			const f = __meta.Message[k];
			Int.enc(buf, k);
			f[1].enc(buf, v[f[0]]);
		}
	},

	dec(buf) {
		const res = {};
		for(let n = Map.decHeader(buf); n > 0; --n) {
			const f = __meta.Message[Int.dec(buf)];
			if(f) {
				res[f[0]] = f[1].dec(buf);
			} else {
				Any.dec(buf);
			}
		}
		return res;
	},
};

// Replacement describes a variable piece of text in a message which will be replaced
// during runtime. The key defines the variable's name which will be passed in. The type
// contains more details about the particular replacement.
export const Replacement = {
	enc(buf, v) {
		Map.encHeader(buf, 4);
		for(const k in __meta.Replacement) {
			const f = __meta.Replacement[k];
			Int.enc(buf, k);
			f[1].enc(buf, v[f[0]]);
		}
	},

	dec(buf) {
		const res = {};
		for(let n = Map.decHeader(buf); n > 0; --n) {
			const f = __meta.Replacement[Int.dec(buf)];
			if(f) {
				res[f[0]] = f[1].dec(buf);
			} else {
				Any.dec(buf);
			}
		}
		return res;
	},
};

// ReplacementDetails holds the details for particular replacements. The special
// EmptyDetails branch indicates that there a no details for the replacement type.
export const ReplacementDetails = {
	enc(buf, v) {
		Arr.encHeader(buf, 2);

		const k = __meta.ReplacementDetails.keyof(v);
		Int.enc(buf, k);
		__meta.ReplacementDetails[k].enc(buf, v);
	},

	dec(buf) {
		Arr.decHeader(buf, 2);

		const t = __meta.ReplacementDetails[Int.dec(buf)];
		if(!t) {
			throw new TypeError("invalid union type");
		}
		return t.dec(buf);
	},
};

// ReplacementType describes the type of a replacement. Each type contains the details
// necessary to render the variable's value.
export const ReplacementType = Int

// PluralType is an enumeration for the types of a plural form.
export const PluralType = Int

// EmptyDetails describes a special type for a replacement that has no further
// details attached.
export const EmptyDetails = {
	enc(buf, v) {
		Map.encHeader(buf, 0);
		for(const k in __meta.EmptyDetails) {
			const f = __meta.EmptyDetails[k];
			Int.enc(buf, k);
			f[1].enc(buf, v[f[0]]);
		}
	},

	dec(buf) {
		const res = {};
		for(let n = Map.decHeader(buf); n > 0; --n) {
			const f = __meta.EmptyDetails[Int.dec(buf)];
			if(f) {
				res[f[0]] = f[1].dec(buf);
			} else {
				Any.dec(buf);
			}
		}
		return res;
	},
};

// MoneyDetails contains the replacement details for amounts of money.
export const MoneyDetails = {
	enc(buf, v) {
		Map.encHeader(buf, 1);
		for(const k in __meta.MoneyDetails) {
			const f = __meta.MoneyDetails[k];
			Int.enc(buf, k);
			f[1].enc(buf, v[f[0]]);
		}
	},

	dec(buf) {
		const res = {};
		for(let n = Map.decHeader(buf); n > 0; --n) {
			const f = __meta.MoneyDetails[Int.dec(buf)];
			if(f) {
				res[f[0]] = f[1].dec(buf);
			} else {
				Any.dec(buf);
			}
		}
		return res;
	},
};

// PluralDetails contains the replacement details for plurals. Depending on the
// variable, different text for each plural rule can be selected. It contains
// the variants for the supported plural tags and custom overwrites.
export const PluralDetails = {
	enc(buf, v) {
		Map.encHeader(buf, 3);
		for(const k in __meta.PluralDetails) {
			const f = __meta.PluralDetails[k];
			Int.enc(buf, k);
			f[1].enc(buf, v[f[0]]);
		}
	},

	dec(buf) {
		const res = {};
		for(let n = Map.decHeader(buf); n > 0; --n) {
			const f = __meta.PluralDetails[Int.dec(buf)];
			if(f) {
				res[f[0]] = f[1].dec(buf);
			} else {
				Any.dec(buf);
			}
		}
		return res;
	},
};

// SelectDetails contains the replacement details to select a text fragment
// depending on the given variable. The fallback is an optional value which
// describes the default case.
export const SelectDetails = {
	enc(buf, v) {
		Map.encHeader(buf, 2);
		for(const k in __meta.SelectDetails) {
			const f = __meta.SelectDetails[k];
			Int.enc(buf, k);
			f[1].enc(buf, v[f[0]]);
		}
	},

	dec(buf) {
		const res = {};
		for(let n = Map.decHeader(buf); n > 0; --n) {
			const f = __meta.SelectDetails[Int.dec(buf)];
			if(f) {
				res[f[0]] = f[1].dec(buf);
			} else {
				Any.dec(buf);
			}
		}
		return res;
	},
};

// required collection types
const _IntMessageMap = TypedMap(Int, Message);
const _MessageArr = TypedArr(Message);
const _PluralArr = TypedArr(Plural);
const _PluralRuleArr = TypedArr(PluralRule);
const _PluralTagMessageMap = TypedMap(PluralTag, Message);
const _RangeArr = TypedArr(Range);
const _ReplacementArr = TypedArr(Replacement);
const _StrArr = TypedArr(Str);
const _StrMessageMap = TypedMap(Str, Message);

// Metadata for struct and union types
const __meta = {
	Catalog: {
		1: ["version", Int],
		2: ["locale", Locale],
		3: ["messages", _MessageArr],
	},
	Symbols: {
		1: ["decimal", Str],
		2: ["group", Str],
		3: ["percent", Str],
		4: ["minus", Str],
		5: ["inf", Str],
		6: ["nan", Str],
		7: ["zero", Uint],
	},
	NumberFormat: {
		1: ["symbols", Symbols],
		2: ["positivePrefix", Str],
		3: ["positiveSuffix", Str],
		4: ["negativePrefix", Str],
		5: ["negativeSuffix", Str],
		6: ["minIntegerDigits", Int],
		7: ["minFractionDigits", Int],
		8: ["maxFractionDigits", Int],
		9: ["primaryIntegerGrouping", Int],
		10: ["secondaryIntegerGrouping", Int],
		11: ["fractionGrouping", Int],
	},
	Range: {
		1: ["lowerBound", Int],
		2: ["upperBound", Int],
	},
	PluralRule: {
		1: ["operand", Operand],
		2: ["modulo", Int],
		3: ["negate", Bool],
		4: ["ranges", _RangeArr],
		5: ["connective", Connective],
	},
	Plural: {
		1: ["tag", PluralTag],
		2: ["rules", _PluralRuleArr],
	},
	Locale: {
		1: ["id", Str],
		2: ["decimalFormat", NumberFormat],
		3: ["moneyFormat", NumberFormat],
		4: ["percentFormat", NumberFormat],
		5: ["cardinalPlurals", _PluralArr],
		6: ["ordinalPlurals", _PluralArr],
	},
	Message: {
		1: ["section", Str],
		2: ["key", Str],
		3: ["text", _StrArr],
		4: ["replacements", _ReplacementArr],
	},
	Replacement: {
		1: ["key", Str],
		2: ["textPos", Int],
		3: ["type", ReplacementType],
		4: ["details", ReplacementDetails],
	},
	ReplacementDetails: {
		1: EmptyDetails,
		2: MoneyDetails,
		3: PluralDetails,
		4: SelectDetails,
		keyof(v) {
			switch(typeof v) {
			case "object":
				if(v) {
					if("currency" in v) {
						return 2; // MoneyDetails
					}
					if("type" in v && "variants" in v && "custom" in v) {
						return 3; // PluralDetails
					}
					if("cases" in v && "fallback" in v) {
						return 4; // SelectDetails
					}
				}
				return 1; // EmptyDetails
			default:
				throw new TypeError("invalid union type");
			}
		},
	},
	MoneyDetails: {
		1: ["currency", Str],
	},
	PluralDetails: {
		1: ["type", PluralType],
		2: ["variants", _PluralTagMessageMap],
		3: ["custom", _IntMessageMap],
	},
	SelectDetails: {
		1: ["cases", _StrMessageMap],
		2: ["fallback", Str],
	},
};
