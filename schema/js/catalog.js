// Code generated by mprotc.
// Do not edit.

import {Bool, Int, Str, TypedArr, TypedMap, Uint, structDecoder, structEncoder, unionDecoder, unionEncoder} from "messagepack";


// Catalog holds the data for a message catalog which includes localized
// messages and the locale information needed to format numbers and plurals.
export const Catalog = {
	enc(buf, v) { __codec.enc(0, structEncoder, buf, v); },
	dec(buf) { return __codec.dec(0, structDecoder, buf); },
};

// Symbols holds all the symbols that are used to format a number in a specific locale.
export const Symbols = {
	enc(buf, v) { __codec.enc(1, structEncoder, buf, v); },
	dec(buf) { return __codec.dec(1, structDecoder, buf); },
};

// NumberFormat holds all relevant information to format a number in a specific locale.
export const NumberFormat = {
	enc(buf, v) { __codec.enc(2, structEncoder, buf, v); },
	dec(buf) { return __codec.dec(2, structDecoder, buf); },
};

// PluralTag is an enumeration of supported plural types. Each plural tag
// can have its own translation text.
export const PluralTag = Int

// Operand represents an operand in a plural rule.
export const Operand = Int

// Connective represents a logical connective for two plural rules. Two plural
// rules can be connected by a conjunction ('and' operator) or a disjunction
// ('or' operator). The conjunction binds more tightly.
export const Connective = Int

// Range represents an integer range, where both bounds are inclusive.
// If the lower bound equals the upper bound, the range will collapse
// to a single value.
export const Range = {
	enc(buf, v) { __codec.enc(3, structEncoder, buf, v); },
	dec(buf) { return __codec.dec(3, structDecoder, buf); },
};

// PluralRule holds the data for a single plural rule. The Modulo field defines the
// modulo divisor for the operand. If Modulo is zero, no remainder has to be calculated.
//
// The plural rule could be connected with another rule. If so, the Connective field is
// set to the respective value (Conjunction or Disjunction). Otherwise the Connective
// field is set to None and there is no follow-up rule.
//
// Example for a plural rule: i%10=1..3
export const PluralRule = {
	enc(buf, v) { __codec.enc(4, structEncoder, buf, v); },
	dec(buf) { return __codec.dec(4, structDecoder, buf); },
};

// Plural represents a single plural form. It holds a collection of plural rules
// for a specific plural tag where all rules are connected with each other (see
// Rule and Connective).
export const Plural = {
	enc(buf, v) { __codec.enc(5, structEncoder, buf, v); },
	dec(buf) { return __codec.dec(5, structDecoder, buf); },
};

// Locale holds the data which is necessary to format data in a region
// specific format.
export const Locale = {
	enc(buf, v) { __codec.enc(6, structEncoder, buf, v); },
	dec(buf) { return __codec.dec(6, structDecoder, buf); },
};

// Message holds the data for a single message. Each message consists of
// a list of fragments which has to be concatenated to receive the final
// message text. If the message does not contain any replacement variables,
// there will only be a single string fragment.
export const Message = {
	enc(buf, v) { __codec.enc(7, structEncoder, buf, v); },
	dec(buf) { return __codec.dec(7, structDecoder, buf); },
};

// Replacement describes a variable piece of text in a message which will be replaced
// during runtime. The key defines the variable's name which will be passed in. The type
// contains more details about the particular replacement.
export const Replacement = {
	enc(buf, v) { __codec.enc(8, structEncoder, buf, v); },
	dec(buf) { return __codec.dec(8, structDecoder, buf); },
};

// ReplacementDetails holds the details for particular replacements. The special
// EmptyDetails branch indicates that there a no details for the replacement type.
export const ReplacementDetails = {
	enc(buf, v) { __codec.enc(9, unionEncoder, buf, v); },
	dec(buf) { return __codec.dec(9, unionDecoder, buf); },
};

// ReplacementType describes the type of a replacement. Each type contains the details
// necessary to render the variable's value.
export const ReplacementType = Int

// PluralType is an enumeration for the types of a plural form.
export const PluralType = Int

// EmptyDetails describes a special type for a replacement that has no further
// details attached.
export const EmptyDetails = {
	enc(buf, v) { __codec.enc(10, structEncoder, buf, v); },
	dec(buf) { return __codec.dec(10, structDecoder, buf); },
};

// MoneyDetails contains the replacement details for amounts of money.
export const MoneyDetails = {
	enc(buf, v) { __codec.enc(11, structEncoder, buf, v); },
	dec(buf) { return __codec.dec(11, structDecoder, buf); },
};

// PluralDetails contains the replacement details for plurals. Depending on the
// variable, different text for each plural rule can be selected. It contains
// the variants for the supported plural tags and custom overwrites.
export const PluralDetails = {
	enc(buf, v) { __codec.enc(12, structEncoder, buf, v); },
	dec(buf) { return __codec.dec(12, structDecoder, buf); },
};

// SelectDetails contains the replacement details to select a text fragment
// depending on the given variable. The fallback is an optional value which
// describes the default case.
export const SelectDetails = {
	enc(buf, v) { __codec.enc(13, structEncoder, buf, v); },
	dec(buf) { return __codec.dec(13, structDecoder, buf); },
};

// required collection types
const _IntMessageMap = TypedMap(Int, Message);
const _MessageArr = TypedArr(Message);
const _PluralArr = TypedArr(Plural);
const _PluralRuleArr = TypedArr(PluralRule);
const _PluralTagMessageMap = TypedMap(PluralTag, Message);
const _RangeArr = TypedArr(Range);
const _ReplacementArr = TypedArr(Replacement);
const _StrArr = TypedArr(Str);
const _StrMessageMap = TypedMap(Str, Message);

const __codec = {
	0: { // Catalog
		1: ["version", Int],
		2: ["locale", Locale],
		3: ["messages", _MessageArr],
	},
	1: { // Symbols
		1: ["decimal", Str],
		2: ["group", Str],
		3: ["percent", Str],
		4: ["minus", Str],
		5: ["inf", Str],
		6: ["nan", Str],
		7: ["zero", Uint],
	},
	2: { // NumberFormat
		1: ["symbols", Symbols],
		2: ["positivePrefix", Str],
		3: ["positiveSuffix", Str],
		4: ["negativePrefix", Str],
		5: ["negativeSuffix", Str],
		6: ["minIntegerDigits", Int],
		7: ["minFractionDigits", Int],
		8: ["maxFractionDigits", Int],
		9: ["primaryIntegerGrouping", Int],
		10: ["secondaryIntegerGrouping", Int],
		11: ["fractionGrouping", Int],
	},
	3: { // Range
		1: ["lowerBound", Int],
		2: ["upperBound", Int],
	},
	4: { // PluralRule
		1: ["operand", Operand],
		2: ["modulo", Int],
		3: ["negate", Bool],
		4: ["ranges", _RangeArr],
		5: ["connective", Connective],
	},
	5: { // Plural
		1: ["tag", PluralTag],
		2: ["rules", _PluralRuleArr],
	},
	6: { // Locale
		1: ["id", Str],
		2: ["decimalFormat", NumberFormat],
		3: ["moneyFormat", NumberFormat],
		4: ["percentFormat", NumberFormat],
		5: ["cardinalPlurals", _PluralArr],
		6: ["ordinalPlurals", _PluralArr],
	},
	7: { // Message
		1: ["section", Str],
		2: ["key", Str],
		3: ["text", _StrArr],
		4: ["replacements", _ReplacementArr],
	},
	8: { // Replacement
		1: ["key", Str],
		2: ["textPos", Int],
		3: ["type", ReplacementType],
		4: ["details", ReplacementDetails],
	},
	9: { // ReplacementDetails
		1: EmptyDetails,
		2: MoneyDetails,
		3: PluralDetails,
		4: SelectDetails,
		ordinalOf(v) {
			switch(typeof v) {
			case "object":
				if(v) {
					if("currency" in v) {
						return 2; // MoneyDetails
					}
					if("type" in v && "variants" in v && "custom" in v) {
						return 3; // PluralDetails
					}
					if("cases" in v && "fallback" in v) {
						return 4; // SelectDetails
					}
				}
				return 1; // EmptyDetails
			default:
				throw new TypeError("invalid union type");
			}
		},
	},
	10: { // EmptyDetails
	},
	11: { // MoneyDetails
		1: ["currency", Str],
	},
	12: { // PluralDetails
		1: ["type", PluralType],
		2: ["variants", _PluralTagMessageMap],
		3: ["custom", _IntMessageMap],
	},
	13: { // SelectDetails
		1: ["cases", _StrMessageMap],
		2: ["fallback", Str],
	},
	enc(ord, newEnc, buf, v) { (this[ord].enc = this[ord].enc || newEnc(this[ord]))(buf, v) },
	dec(ord, newDec, buf) { return (this[ord].dec = this[ord].dec || newDec(this[ord]))(buf) },
};
